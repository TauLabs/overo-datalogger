/**
 ******************************************************************************
 * @addtogroup UAVObjects UAVObject set for this firmware
 * @{
 * @addtogroup OpenLRS OpenLRS
 * @brief Binding settings for OpenLRS
 *
 *
 * @file       openlrs.h
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
 * @author     Tau Labs, http://taulabs.org, Copyright (C) 2012-2015
 * @brief      Include files for the OpenLRS object. This file has been 
 *             automatically generated by the UAVObjectGenerator.
 * 
 * @note       Object definition file: openlrs.xml. 
 *             This is an automatically generated file.
 *             DO NOT modify manually.
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 *****************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#ifndef OPENLRS_H
#define OPENLRS_H

#include "pios_queue.h"
#include "uavoversion.h"



// Object constants
#define OPENLRS_OBJID 0x44F8119A
#define OPENLRS_ISSINGLEINST 1
#define OPENLRS_ISSETTINGS 1
#define OPENLRS_NUMBYTES 52

// Generic interface functions
int32_t OpenLRSInitialize();
UAVObjHandle OpenLRSHandle();
void OpenLRSSetDefaults(UAVObjHandle obj, uint16_t instId);

// Object data
typedef struct {
    uint32_t serial_baudrate;
    uint32_t rf_frequency;
    uint32_t rf_magic;
    uint32_t beacon_frequency;
    uint32_t failsafe_delay;
    uint8_t version;
    uint8_t rf_power;
    uint8_t rf_channel_spacing;
    uint8_t hopchannel[24];
    uint8_t modem_params;
    uint8_t flags;
    uint8_t beacon_delay;
    uint8_t beacon_period;
    uint8_t RSSI_Type;

} __attribute__((packed)) __attribute__((aligned(4))) OpenLRSData;

// Typesafe Object access functions
/**
 * @function OpenLRSGet(dataOut)
 * @brief Populate a OpenLRSData object
 * @param[out] dataOut 
 */
static inline int32_t OpenLRSGet(OpenLRSData *dataOut) { return UAVObjGetData(OpenLRSHandle(), dataOut); }

static inline int32_t OpenLRSSet(const OpenLRSData *dataIn) { return UAVObjSetData(OpenLRSHandle(), dataIn); }

static inline int32_t OpenLRSInstGet(uint16_t instId, OpenLRSData *dataOut) { return UAVObjGetInstanceData(OpenLRSHandle(), instId, dataOut); }

static inline int32_t OpenLRSInstSet(uint16_t instId, const OpenLRSData *dataIn) { return UAVObjSetInstanceData(OpenLRSHandle(), instId, dataIn); }

static inline int32_t OpenLRSConnectQueue(struct pios_queue *queue) { return UAVObjConnectQueue(OpenLRSHandle(), queue, EV_MASK_ALL_UPDATES); }

static inline int32_t OpenLRSConnectCallback(UAVObjEventCallback cb) { return UAVObjConnectCallback(OpenLRSHandle(), cb, EV_MASK_ALL_UPDATES); }

static inline uint16_t OpenLRSCreateInstance() { return UAVObjCreateInstance(OpenLRSHandle(), &OpenLRSSetDefaults); }

static inline void OpenLRSRequestUpdate() { UAVObjRequestUpdate(OpenLRSHandle()); }

static inline void OpenLRSRequestInstUpdate(uint16_t instId) { UAVObjRequestInstanceUpdate(OpenLRSHandle(), instId); }

static inline void OpenLRSUpdated() { UAVObjUpdated(OpenLRSHandle()); }

static inline void OpenLRSInstUpdated(uint16_t instId) { UAVObjInstanceUpdated(OpenLRSHandle(), instId); }

static inline int32_t OpenLRSGetMetadata(UAVObjMetadata *dataOut) { return UAVObjGetMetadata(OpenLRSHandle(), dataOut); }

static inline int32_t OpenLRSSetMetadata(const UAVObjMetadata *dataIn) { return UAVObjSetMetadata(OpenLRSHandle(), dataIn); }

static inline int8_t OpenLRSReadOnly() { return UAVObjReadOnly(OpenLRSHandle()); }

static inline uint16_t OpenLRSGetNumInstances(){ return UAVObjGetNumInstances(OpenLRSHandle()); }

static inline uint32_t OpenLRSGetNumBytes(){ return UAVObjGetNumBytes(OpenLRSHandle()); }

// Field information
// Field serial_baudrate information
// Field rf_frequency information
// Field rf_magic information
// Field beacon_frequency information
// Field failsafe_delay information
// Field version information
// Field rf_power information
// Field rf_channel_spacing information
// Field hopchannel information
/* Number of elements for field hopchannel */
#define OPENLRS_HOPCHANNEL_NUMELEM 24
// Field modem_params information
// Field flags information
// Field beacon_delay information
// Field beacon_period information
// Field RSSI_Type information
/* Enumeration options for field RSSI_Type */
typedef enum { OPENLRS_RSSI_TYPE_COMBINED=0, OPENLRS_RSSI_TYPE_RSSI=1, OPENLRS_RSSI_TYPE_LINKQUALITY=2 }  __attribute__((packed)) OpenLRSRSSI_TypeOptions;
/* Max value of any option in topmost parent RSSI_Type of field RSSI_Type */
#define OPENLRS_RSSI_TYPE_GLOBAL_MAXOPTVAL 2
/* Max value of any option in field RSSI_Type */
#define OPENLRS_RSSI_TYPE_MAXOPTVAL 2
/* Ensure field RSSI_Type contains valid data */
static inline bool OpenLRSRSSI_TypeIsValid( uint8_t CurrentRSSI_Type ) { return CurrentRSSI_Type < OPENLRS_RSSI_TYPE_MAXOPTVAL; }


// set/Get functions
extern void OpenLRSserial_baudrateSet( uint32_t *Newserial_baudrate );
extern void OpenLRSserial_baudrateGet( uint32_t *Newserial_baudrate );
extern void OpenLRSrf_frequencySet( uint32_t *Newrf_frequency );
extern void OpenLRSrf_frequencyGet( uint32_t *Newrf_frequency );
extern void OpenLRSrf_magicSet( uint32_t *Newrf_magic );
extern void OpenLRSrf_magicGet( uint32_t *Newrf_magic );
extern void OpenLRSbeacon_frequencySet( uint32_t *Newbeacon_frequency );
extern void OpenLRSbeacon_frequencyGet( uint32_t *Newbeacon_frequency );
extern void OpenLRSfailsafe_delaySet( uint32_t *Newfailsafe_delay );
extern void OpenLRSfailsafe_delayGet( uint32_t *Newfailsafe_delay );
extern void OpenLRSversionSet( uint8_t *Newversion );
extern void OpenLRSversionGet( uint8_t *Newversion );
extern void OpenLRSrf_powerSet( uint8_t *Newrf_power );
extern void OpenLRSrf_powerGet( uint8_t *Newrf_power );
extern void OpenLRSrf_channel_spacingSet( uint8_t *Newrf_channel_spacing );
extern void OpenLRSrf_channel_spacingGet( uint8_t *Newrf_channel_spacing );
extern void OpenLRShopchannelSet( uint8_t *Newhopchannel );
extern void OpenLRShopchannelGet( uint8_t *Newhopchannel );
extern void OpenLRSmodem_paramsSet( uint8_t *Newmodem_params );
extern void OpenLRSmodem_paramsGet( uint8_t *Newmodem_params );
extern void OpenLRSflagsSet( uint8_t *Newflags );
extern void OpenLRSflagsGet( uint8_t *Newflags );
extern void OpenLRSbeacon_delaySet( uint8_t *Newbeacon_delay );
extern void OpenLRSbeacon_delayGet( uint8_t *Newbeacon_delay );
extern void OpenLRSbeacon_periodSet( uint8_t *Newbeacon_period );
extern void OpenLRSbeacon_periodGet( uint8_t *Newbeacon_period );
extern void OpenLRSRSSI_TypeSet( uint8_t *NewRSSI_Type );
extern void OpenLRSRSSI_TypeGet( uint8_t *NewRSSI_Type );


#endif // OPENLRS_H

/**
 * @}
 * @}
 */
